
---
title: "Dataset: Beach Litter - Material categories percentage per year - Other sources"
author: Document produced by http://www.marine-analyst.eu
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    df_print: paged
    number_section: yes
    theme: default
    toc: yes
    toc_depth: 2
    toc_float:
      collapsed: no
      smooth_scroll: yes
---

```{r setup, include=FALSE}
library(knitr)
library(kableExtra)
knitr::opts_chunk$set(
  eval = TRUE,
	echo = TRUE,
	fig.align = "center",
	message = FALSE,
	warning = FALSE,
	fig.width=5.5,
	out.width = "100%"
)
# clean environment
rm(list=ls())
gc()
```
```{r, include=FALSE, results='hide'}
# Edit the longitude and latitude coordinates to define the geographical area:
minlon=11.3 #minimum longitude
minlat=53.6 #minimum latitude
maxlon=15.5 #maximum longitude
maxlat=55.9 #maximum latitude
wdpaid=paste(minlon,minlat,maxlon,maxlat,sep="_")
Sessionid <- 'test'
wdpaidsplit <- unlist(strsplit(wdpaid, "[_]"))
xmin <- as.numeric(wdpaidsplit[1])
ymin <- as.numeric(wdpaidsplit[2])
xmax <- as.numeric(wdpaidsplit[3])
ymax <- as.numeric(wdpaidsplit[4])
temp_path<- "."
```
```{r, include=FALSE, results='hide'}
source_provider <- "EMODnet Chemistry"
source_provider_url <- "https://www.emodnet.eu"
layer_title<-"Beach Litter - Material categories percentage per year - Other sources"
layer="bl_materialcategories_cleaning"
wfs_url <- "https://www.ifremer.fr/services/wfs/emodnet_chemistry2?"
wms_url <- "https://www.ifremer.fr/services/wms/emodnet_chemistry2?"
wms_layer="bl_materialcategories_cleaning"
layer_id<-751
map_legend <- "year"
map_legend_list <- c("cloth_perc","glass_perc","metal_perc","medical_perc","artificial_perc","other_perc","paper_perc","pollutants_perc","rubber_perc","wood_perc","sanitary_perc")
map_legend_list_title <- c("Beach Litter - 'Artificial' in percent","Beach Litter - 'Cloth' in percent","Beach Litter - 'Glass' in percent","Beach Litter - 'Medical' in percent","Beach Litter - 'Metal' in percent","Beach Litter - 'Other' in percent","Beach Litter - 'Paper' in percent","Beach Litter - 'Pollutants' in percent","Beach Litter - 'Wood' in percent","Beach Litter - 'Rubber' in percent","Beach Litter - 'Sanitary' in percent")
map_label<-"beachcode"
link_csv<-paste0("./Report-", layer_id, "_", Sessionid, "_", wdpaid, "-csvfile.csv",sep="")
csvfile_name = paste("Report-", layer_id, "_", Sessionid, "_", wdpaid, "-csvfile.csv",sep="")
link_geojson<-paste0("./Report-", layer_id, "_", Sessionid, "_", wdpaid, "-geojsonfile.geojson",sep="")
geojsonfile_name = paste("Report-", layer_id, "_", Sessionid, "_", wdpaid, "-geojsonfile.geojson",sep="")
temp_path<- "/var/www/html/rprocessing/temp/"
```

```{r, include=FALSE, results='hide'}
library(rgdal)
library(downloader)
library(ggplot2)
library(mapdata)
library(ggmap)
library(ggrepel)
library(ows4R) # interface for OGC webservices
library(httr) # generic webservice package (build_url)
library(sf) # simple features packages for handling vector GIS data
library(tidyverse) # a suite of packages for data wrangling, transformation, plotting, ...
library(rasterVis)
library(rgeos)
library(sp)
library(raster)
```

# Data information

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100&#37;><TR><TD WIDTH=100&#37; VALIGN=TOP><DIV ALIGN=JUSTIFY class=><DIV id=standard>This visualization product displays marine litter material categories percentage per year per beach from research &amp; cleaning operations. EMODnet Chemistry included the gathering of marine litter in its 3rd phase. Since the beginning of 2018, data of beach litter have been gathered and processed in the EMODnet Chemistry Marine Litter Database (MLDB). The harmonization of all the data has been the most challenging task considering the heterogeneity of the data sources, sampling protocols and reference lists used on a European scale. Preliminary processing were necessary to harmonize all the data : - Exclusion of OSPAR 1000 protocol, - Separation of monitoring surveys from research &amp; cleaning operations - Exclusion of beaches with no coordinates - Normalization of survey lengths and survey numbers per year - Some categories &amp; some litter types have been removed To calculate percentages, formula applied is : Material (%) = (total number of items (normalized at 100 m) of each material category)/(total number of items (normalized at 100 m) of all categories)*100 The material categories differ between reference lists. In order to apply a common procedure for all the surveys, the material categories have been harmonized. Eleven material categories have taken into account for this product and information on data processing and calculation are detailed in the document attached p14.</DIV></DIV></TD></TR></TABLE>

```{r, include=FALSE, results='hide'}
# Script for Wekeo environment
sr=SpatialPolygons(list(Polygons(list(Polygon(cbind(c(xmin, xmin, xmax, xmax),c(ymax, ymin, ymin, ymax)))),"1")))
mpa=SpatialPolygonsDataFrame(sr, data.frame(cbind(1:1), row.names=c("1")))
proj4string(mpa)<-CRS("+proj=longlat +datum=WGS84")
bbox<-paste(xmin,ymin,xmax,ymax,sep=",")
```

```{r, include=FALSE, results='hide'}
# Link to Marine Analyst dataset page
link_marineanalyst <- paste0("http://marine-analyst.eu/dev.py?N=simple&O=",layer_id,"&maxlat=",ymax,"&maxlon=",xmax,"&minlon=",xmin,"&minlat=",ymin)
# Link to open the openlayer page for EMODnet HA
openlayer<-paste0("http://www.marine-analyst.eu/openlayers3/openlayer.py?wms_url=",wms_url,"/wms&wms_layer=",layer,"&bbox=",bbox)
```

## Metadata

Access <A HREF=`r toString(link_marineanalyst)` TARGET=_blank>metadata</A> from landing page<br>

# Geographical extent

## Coordinates

<A HREF=`r toString(link_marineanalyst)` TARGET=_blank>

```{r,echo=FALSE}
print (paste("West-Longitude:",round(xmin,2)))
print (paste("South-Latitude:",round(ymin,2)))
print (paste("East-Longitude:",round(xmax,2)))
print (paste("North-Latitude:",round(ymax,2)))
```

</a>

## Defined area

```{r ,echo=FALSE}
value<-(xmax-xmin)*(ymax-ymin)
if (value > 100) {
      zoom_value<-6
} else if (value > 1) {
      zoom_value<-7
} else {
      zoom_value<-8
}
base<-get_map(location=c(xmin-1,ymin-1,xmax+1,ymax+1), zoom=zoom_value, maptype="terrain-background", source = "stamen")
terrain <- ggmap(base)
map <- terrain + geom_polygon(data=mpa,aes(x=long,y=lat,group=group,fill="mpa"),colour="green",fill="blue",alpha=.1) +
ggtitle("")+xlab("Longitude")+ylab("Latitude")
plot(map)
```

Map tiles by <a href="http://stamen.com">Stamen Design</a>, under <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="http://openstreetmap.org">OpenStreetMap</a>, under <a href="http://www.openstreetmap.org/copyright">ODbL</a>.

# `r toString(layer_title)`

## Access data

The Web Feature Service (WFS) of the `r toString(source_provider)` portal allows collecting the data:<BR><A HREF=`r toString(wfs_url)`service=WFS&request=GetCapabilities&version=1.1.0 TARGET=_blank>`r toString(wfs_url)`service=WFS&request=GetCapabilities&version=1.1.0</A><BR><BR>**Available labels:**

```{r,echo=FALSE}
# define a function for the DescribeFeatureType request
url <- parse_url(wfs_url)
url$query <- list(service = "WFS",
                  version = "1.0.0",
                  request = "GetCapabilities")
request <- build_url(url)
WFSserver_client <- WFSClient$new(wfs_url, serviceVersion = "1.0.0")
# list of Feature type
WFS_Colnames <- WFSserver_client$
  getCapabilities()$
  findFeatureTypeByName(layer)$
  getDescription() %>%
  map_chr(function(x){x$getName()})
WFS_Colnames
```

```{r, include=FALSE, results='hide'}
url$query <- list(service = "wfs",
                  version = "1.0.0",
                  request = "GetFeature",
                  typename = layer,
                  srsName = "EPSG:4326",
                  outputFormat = "GML3")
request <- build_url(url)
wfs_data <- read_sf(request)
#Transform mpa in Simple feature collection to perform the subsetting because wfs_data contains the whole info - use bbox and tyname are exclusive (Mapserver)
mpaSP <- as(mpa, "SpatialPolygonsDataFrame")
wfs_data<-wfs_data[st_as_sf(mpaSP),]
# get the geometry as lat and lon cols
wfs_data <- wfs_data %>% dplyr::mutate(lat = sf::st_coordinates(.)[,1],lon = sf::st_coordinates(.)[,2])
```

```{r, include=FALSE}
st_write(wfs_data, file.path(temp_path,csvfile_name), layer = csvfile_name, driver = "csv", delete_dsn = TRUE)
st_write(wfs_data, file.path(temp_path,geojsonfile_name), layer = geojsonfile_name, driver = "GeoJSON", delete_dsn = TRUE)
```

<br>**Download data for the defined geographical extent:**<br><TABLE BORDER=1 WIDTH=100%><TR><TD ALIGN=CENTER>Excel file</TD><TD ALIGN=CENTER>Geographic information</TD></TR><TR><TD ALIGN=CENTER><A HREF=`r toString(link_csv)`>**csv**</A></TD><TD ALIGN=CENTER><A HREF=`r toString(link_geojson)` TARGET=_blank>**geojson**</A></TD></TR></TABLE>

## Table

Browse table's columns by using the left and right arrows. Turn the table's pages with help of the previous/next buttons.<br><br>

```{r ,echo=FALSE}
if(nrow(wfs_data) > 0) {
wfs_data
} else {
print("No data available for the defined geographical extent")
}
```

## Maps

```{r,echo=FALSE}
if(nrow(wfs_data) > 0) {for (data in 1:length(map_legend_list)){map_legend_item <-map_legend_list[data]map_legend_item_title <-map_legend_list_title[data]map <- ggplot() +	borders("worldHires", fill = "gray", colour = "black", xlim = range(xmin,xmax), ylim = range(ymin,ymax), size = .25) +theme(legend.position = "bottom") +    theme(panel.grid.minor.y= element_blank(), panel.grid.minor.x = element_blank()) +    geom_polygon(data=mpa,aes(x=long,y=lat,group=group,fill="mpa"),colour="green",fill="blue",alpha=.1) +	geom_sf() +	geom_point(data = wfs_data, aes(x = lat, y = lon, size =.data[[map_legend_item]]), fill = "red", color = "red", alpha = .4) +	coord_sf(xlim = c(xmin, xmax),ylim = c(ymin, ymax))+	ggtitle(map_legend_item_title)+xlab("Longitude (x)")+ylab("Latitude (y)")plot(map)}} else {print("No data available for the defined geographical extent")}
```

## Map with id

```{r,echo=FALSE}
if(nrow(wfs_data) > 0) {centroid<- st_centroid(wfs_data)centroid<- cbind(wfs_data, st_coordinates(st_centroid(wfs_data$geometry)))map <- ggplot() +    borders("worldHires", fill = "gray", colour = "black", xlim = range(xmin,xmax), ylim = range(ymin,ymax), size = .25) +theme(legend.position = "bottom") +    theme(panel.grid.minor.y= element_blank(), panel.grid.minor.x = element_blank()) +    geom_polygon(data=mpa,aes(x=long,y=lat,group=group,fill="mpa"),colour="green",fill="blue",alpha=.1) +    geom_sf() +    geom_point(data = wfs_data, aes(x = lat, y = lon), fill = "blue", color = "blue", alpha = .4) +    geom_text(data=centroid,aes(x=lat, y=lon, label=.data[[map_label]]), color = "black", fontface = "bold", size=2, hjust= 0, vjust=2, check_overlap = TRUE) +    coord_sf(xlim = c(xmin, xmax),ylim = c(ymin, ymax))+    ggtitle("")+xlab("Longitude (x)")+ylab("Latitude (y)")map} else {print("No data available for the defined geographical extent")}
```

## Interactive map

Visualise and access data with <A HREF=`r toString(openlayer)` TARGET=_blank>Openlayer (click on the map)<BR>

```{r, include=FALSE}
if(nrow(wfs_data) > 0) {
getWMSlegend<-function (wms_layer)
{
wms_layer<-as.character(wms_layer)
con<-paste0(wms_url,"service=WMS&request=GetLegendGraphic&STYLE=default&sld_version=1.1.0&version=1.3.0&format=image/jpeg&transparent=false&layer=",wms_layer,"")
print(con)
        legend<- "img.png"
        legend <- tempfile(legend)
        download(con, legend, quiet = TRUE, mode = "wb")
        img <- brick(legend)
return(img)
}
wms_legend<-getWMSlegend(wms_layer)
getWMSmap<-function (wms_layer,xmin,xmax,ymin,ymax)
{
width <- 960
height <- as.integer(width * (ymax-ymin) / (xmax-xmin))
wms_layer<-as.character(wms_layer)
bbox <- paste(xmin, ymin, xmax, ymax, sep = ",")
con<-paste0(wms_url,"/wms?SERVICE=WMS&VERSION=1.1.0&request=GetMap&layers=",wms_layer,"&format=image/jpeg&srs=EPSG:4326&bbox=",bbox,"&height=",height,"&width=",width,"")
        wms <- "img.png"
        wms <- tempfile(wms)
        download(con, wms, quiet = TRUE, mode = "wb")
        img <- brick(wms)
names(img) <- c("img.1", "img.2", "img.3")
img[img$img.1 == 255 & img$img.2 == 255 & img$img.3 == 255] <- NA
wms_basemap_url="http://www.gebco.net/data_and_products/gebco_web_services/web_map_service/mapserv"
wms_basemap_layer="gebco_latest"
con<-paste0(wms_basemap_url,"?SERVICE=WMS&VERSION=1.1.0&request=GetMap&layers=",wms_basemap_layer,"&format=image/png&srs=EPSG:4326&bbox=",bbox,"&height=",height,"&width=",width,"")
        wms <- "img.png"
        wms <- tempfile(wms)
        download(con, wms, quiet = TRUE, mode = "wb")
        basemap <- brick(wms)
names(basemap) <- c("img.1", "img.2", "img.3")
img <- merge(basemap,img)
img@extent@xmin <- xmin
img@extent@ymin <- ymin
img@extent@xmax <- xmax
img@extent@ymax <- ymax
proj4string(img)<-CRS("+proj=longlat +datum=WGS84")
return(img)
}
wms_img<-getWMSmap(wms_layer,xmin,xmax,ymin,ymax)
rggbplot <- function(inRGBRst,npix=NA,scale = 'lin'){
  rgblinstretch <- function(rgbDf){
    maxList <- apply(rgbDf,2,max)
    minList <- apply(rgbDf,2,min)
    temp<-rgbDf
    for(i in c(1:3)){
      temp[,i] <- (temp[,i]-minList[i])/(maxList[i]-minList[i])
    }
    return(temp)
  }
  rgbeqstretch<-function(rgbDf){
    temp<-rgbDf
    for(i in c(1:3)){
      unique <- na.omit(temp[,i])
      if (length(unique>0)){
        ecdf<-ecdf(unique)
        temp[,i] <- apply(temp[,i,drop=FALSE],2,FUN=function(x) ecdf(x))
      }
    }
    return(temp)
  }
      npix <- ncell(inRGBRst)
  x <- sampleRegular(inRGBRst, size=npix, asRaster = TRUE)
  dat <- as.data.frame(x, xy=TRUE)
  colnames(dat)[3:5]<-c('r','g','b')
  if(scale=='lin'){
    dat[,3:5]<- rgblinstretch(dat[,3:5])
  } else if(scale=='stretch'){
    dat[,3:5]<- rgbeqstretch(dat[,3:5])
  }
  p <- ggplot()+ geom_tile(data=dat, aes(x=x, y=y, fill=rgb(r,g,b))) + scale_fill_identity()
}
}
```

```{r, echo=FALSE}
if(nrow(wfs_data) > 0) {
map <- rggbplot(wms_img)+
#borders("worldHires", fill = "gray", colour = "black", xlim = range(xmin,xmax), ylim = range(ymin,ymax), size = .25) +
coord_quickmap(xlim=range(xmin,xmax),ylim=range(ymin,ymax))+
ggtitle(layer_title)+xlab("Longitude")+ylab("Latitude")
plot(map)
legend <- rggbplot(wms_legend) + ggtitle("Legend") +
    theme(axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank()) +
	theme(axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank()) +
	coord_fixed()
plot(legend)
} else {
print("No data available for the defined geographical extent")
}
```

</a>
